//Firmware Training Week 4
//MPU 6050 Emulation
//Joe Spall, Varun Madabushi

//***********************************************//
//             DO NOT EDIT THIS FILE             //
//***********************************************//

#include <Wire.h>

#define MPU_ADDR 0x68
#define MPU_REG_SIZE 118

// I2C Registers
#define PWR_MGMT_1 0x6B
#define WHO_AM_I 0x75
#define ACCEL_XOUT_H 0x3B
#define ACCEL_XOUT_L 0x3C
#define ACCEL_YOUT_H 0x3D
#define ACCEL_YOUT_L 0x3E
#define ACCEL_ZOUT_H 0x3F
#define ACCEL_ZOUT_L 0x40
#define ACCEL_CONFIG 0x1C


const float BIT_10_ACC = 1023.0;

int potXPin = A0;
int potYPin = A1;
int potZPin = A2;

volatile uint8_t data[MPU_REG_SIZE];
volatile uint8_t dat_ptr = 0xFF;

void setup()
{
  Wire.begin(MPU_ADDR);  // join i2c bus with address MPU_ADDR
  
  pinMode(potXPin, INPUT);
  pinMode(potYPin, INPUT);  
  pinMode(potZPin, INPUT);
  
  for(int i = 0; i < MPU_REG_SIZE; i++) {
	data[i] = 0xFF; //initializes everything to FF
  }
  //Set initial values
  data[WHO_AM_I] = (uint8_t)0x68;
  data[PWR_MGMT_1] = 0b01000000;
  data[ACCEL_CONFIG] = 0b00000000;
  
  Wire.onReceive(receiveEvent); // register event
  Wire.onRequest(requestEvent);
  
}

void loop()
{
  bool powerState = (data[PWR_MGMT_1] & 0b01000000) == 0;
  //In the sleep state the accelerometers + gyros are not updated
  if(powerState) 
  {
    readAxis();
  }

  delay(10);
}

// data pointer is written value.
// further values end up in the place pointed to by dat_ptr
void receiveEvent(int howMany)
{
  dat_ptr = Wire.read();
  while(Wire.available()) {
    data[dat_ptr] = Wire.read();
  }
}

void requestEvent() {
  uint8_t response[6];
  for(int i = 0; i < 6; i++) {
    uint8_t ind = constrain(dat_ptr + i, 13, MPU_REG_SIZE - 1);
    uint8_t temp = data[ind];
    response[i] = temp;
}
  Wire.write(response,sizeof(response));
}


// Get full-scale accelerometer range.
// The AFS_SEL parameter allows setting the full-scale range of the accelerometer
// sensors, as described in the table below.
//
// <pre>
// 0 = +/- 2g
// 1 = +/- 4g
// 2 = +/- 8g
// 3 = +/- 16g
//
//

float getFullScaleAccelRange()
{
  switch(data[ACCEL_CONFIG] & 0b00011000)
  {
    case 0:
    	return 2.0;
    case 8:
    	return 4.0;
	case 16:
    	return 8.0;
  	case 24:
    	return 16.0;
  }
}

int getLSBSensitivity()
{
  switch(data[ACCEL_CONFIG] & 0b00011000)
  {
    case 0:
    	return 16384;
    case 8:
    	return 8192;
	case 16:
    	return 4096;
  	case 24:
    	return 2048;
  }
}


void readAxis()
{
  float xTemp = 0.5-((float)(analogRead(potXPin))/BIT_10_ACC);
  float yTemp = 0.5-((float)(analogRead(potYPin))/BIT_10_ACC);
  float zTemp = 0.5-((float)(analogRead(potZPin))/BIT_10_ACC);
  
  float currentAccelRange = getFullScaleAccelRange();
  
  xTemp*= (2*currentAccelRange);
  yTemp*= (2*currentAccelRange);
  zTemp*= (2*currentAccelRange);
  
  int currentLSBSen = getLSBSensitivity();
  
  long x = (long)(currentLSBSen*xTemp);
  long y = (long)(currentLSBSen*yTemp);
  long z = (long)(currentLSBSen*zTemp);
  
  // Handle int overflow

  x = constrain(x, -currentAccelRange*currentLSBSen, currentAccelRange*currentLSBSen - 1);
  y = constrain(y, -currentAccelRange*currentLSBSen, currentAccelRange*currentLSBSen - 1);
  z = constrain(z, -currentAccelRange*currentLSBSen, currentAccelRange*currentLSBSen - 1);
  
  data[ACCEL_XOUT_H] = (uint8_t)(x >> 8);
  data[ACCEL_XOUT_L] = (uint8_t)(x);
  data[ACCEL_YOUT_H] = (uint8_t)(y >> 8);
  data[ACCEL_YOUT_L] = (uint8_t)(y);
  data[ACCEL_ZOUT_H] = (uint8_t)(z >> 8);
  data[ACCEL_ZOUT_L] = (uint8_t)(z);
}
